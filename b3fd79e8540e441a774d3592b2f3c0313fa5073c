{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "e20293fa_85cd2164",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-10-05T01:01:38Z",
      "side": 1,
      "message": "I kept the previous review a bit abstract as I was hoping for a refactor to make the implementation async, but given you don\u0027t plan to do that I\u0027ve taken a closer look at the blocking implementation. I\u0027ve made some further comments.",
      "revId": "b3fd79e8540e441a774d3592b2f3c0313fa5073c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "58996044_237df0e5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000926
      },
      "writtenOn": "2023-10-06T12:30:13Z",
      "side": 1,
      "message": "It turned out that the current `kcs_bmc_cdev_raw` driver can\u0027t be used as-is in the code. And the modifications for the driver are not that simple and even if possible probably not worth the effort since the Linux kernel driver approach is on the way.\n\nFor example in some points KCS state machine requires BMC to read STR, but in the process the code can\u0027t read IDR. And the `kcs_bmc_cdev_raw` driver doesn\u0027t satisfy such requirements.\n\nWith these race cases communication is not reliable, sometimes your packets would go flawlessly and sometimes KCS machine would stuck.\n\nThe error that I\u0027ve caught was connected with the `WR_END` command byte:\n\nHOST writes `WR_END\u003d0x62` command, but BMC sees 0x62 as `DATA` (bit 4 in the STR register is read as 0).",
      "revId": "b3fd79e8540e441a774d3592b2f3c0313fa5073c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd18cd2b_fd4372ee",
        "filename": "kcs.c",
        "patchSetId": 5
      },
      "lineNbr": 104,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-10-05T01:01:38Z",
      "side": 1,
      "message": "bit of a nit but this should probably be `(b)` for expansion-safety",
      "range": {
        "startLine": 104,
        "startChar": 39,
        "endLine": 104,
        "endChar": 40
      },
      "revId": "b3fd79e8540e441a774d3592b2f3c0313fa5073c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "514cb631_dd6fd387",
        "filename": "kcs.c",
        "patchSetId": 5
      },
      "lineNbr": 203,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-10-05T01:01:38Z",
      "side": 1,
      "message": "Can we at least implement this internally using `poll(2)`?",
      "range": {
        "startLine": 195,
        "startChar": 0,
        "endLine": 203,
        "endChar": 3
      },
      "revId": "b3fd79e8540e441a774d3592b2f3c0313fa5073c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c3afbc30_c7dda07a",
        "filename": "kcs.c",
        "patchSetId": 5
      },
      "lineNbr": 231,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-10-05T01:01:38Z",
      "side": 1,
      "message": "Can we at least implement this internally using `poll(2)`?",
      "range": {
        "startLine": 223,
        "startChar": 1,
        "endLine": 231,
        "endChar": 3
      },
      "revId": "b3fd79e8540e441a774d3592b2f3c0313fa5073c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f0f480e_f68f00ca",
        "filename": "kcs.c",
        "patchSetId": 5
      },
      "lineNbr": 257,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-10-05T01:01:38Z",
      "side": 1,
      "message": "Is this necessary?",
      "range": {
        "startLine": 250,
        "startChar": 1,
        "endLine": 257,
        "endChar": 3
      },
      "revId": "b3fd79e8540e441a774d3592b2f3c0313fa5073c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "06b8cf64_b31ad1fd",
        "filename": "kcs.c",
        "patchSetId": 5
      },
      "lineNbr": 276,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-10-05T01:01:38Z",
      "side": 1,
      "message": "See the concern about mixing GPL-2 and Apache-2 code.",
      "revId": "b3fd79e8540e441a774d3592b2f3c0313fa5073c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4303fa84_e6e7e69b",
        "filename": "kcs.c",
        "patchSetId": 5
      },
      "lineNbr": 525,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-10-05T01:01:38Z",
      "side": 1,
      "message": "You must terminate the loop and transition to an error state if read_len exceeds 255. We don\u0027t want it to be possible to overflow the buffer.",
      "revId": "b3fd79e8540e441a774d3592b2f3c0313fa5073c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3752d29d_4d15a411",
        "filename": "kcs.c",
        "patchSetId": 5
      },
      "lineNbr": 567,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-10-05T01:01:38Z",
      "side": 1,
      "message": "Why not allocate the packet up front and push the data directly into the packet buffer rather than bounce through a stack buffer?",
      "revId": "b3fd79e8540e441a774d3592b2f3c0313fa5073c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "005ef4cd_05237f9c",
        "filename": "kcs.c",
        "patchSetId": 5
      },
      "lineNbr": 567,
      "author": {
        "id": 1000926
      },
      "writtenOn": "2023-10-05T21:02:56Z",
      "side": 1,
      "message": "We don\u0027t know the allocation size since the `kcs_header-\u003elen` is a part of the received data.\n\nMaybe we can use max possible size here instead (256)? The API is not documented very well, so I\u0027m unsure if this code would lead to the correct MCTP packet for example:\n```\nmctp_pktbuf_alloc(\u0026kcs-\u003ebinding, 256);\nmemcpy(mctp_pktbuf_hdr(pkt), (uint8_t *)(kcs_header + 1), kcs_header-\u003elen);\n```\n\nAlso using static memory instead of the dynamic allocation (malloc/free) is probably easier for the system. Not sure if this relevant though.",
      "parentUuid": "3752d29d_4d15a411",
      "revId": "b3fd79e8540e441a774d3592b2f3c0313fa5073c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "027b0196_d9bf118a",
        "filename": "kcs.c",
        "patchSetId": 5
      },
      "lineNbr": 567,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-10-06T00:09:52Z",
      "side": 1,
      "message": "Your caution is valid, as to implement my suggestion we need to fix up line 589 below:\n\n```\nkcs-\u003ebinding.pkt_size \u003d 256;\n```\n\nWith we can do `mctp_pktbuf_alloc(\u0026kcs-\u003ebinding, 0)`, and then use `mctp_pktbuf_push(\u0026kcs-\u003ebinding, \u0026data, sizeof(data))` for each byte read off the KCS interface (line 524).",
      "parentUuid": "005ef4cd_05237f9c",
      "revId": "b3fd79e8540e441a774d3592b2f3c0313fa5073c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}